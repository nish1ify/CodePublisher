<html><head><head><body><pre><br><br><br><a href = "ActionsAndRules.h.htm">ActionsAndRules.h - ActionsAndRules.h.htm</a><br><a href = "ConfigureParser.h.htm">ConfigureParser.h - ConfigureParser.h.htm</a><br><a href = "Parser.h.htm">Parser.h - Parser.h.htm</a><br><br><br>#ifndef PARSER_H<br>#define PARSER_H<br>/////////////////////////////////////////////////////////////////////<br>//  Parser.h - Analyzes C++ and C# language constructs             //<br>//  ver 1.5                                                        //<br>//  Language:      Visual C++, Visual Studio 2015                  //<br>//  Platform:      Dell XPS 8900, Windows 10                       //<br>//  Application:   Prototype for CSE687 Pr1, Sp09, ...             //<br>//  Author:        Jim Fawcett, CST 4-187, Syracuse University     //<br>//                 (315) 443-3948, jfawcett@twcny.rr.com           //<br>/////////////////////////////////////////////////////////////////////<br>/*<br>  Module Operations: <br>  ==================<br>  This module defines a Parser class.  Its instances collect <br>  semi-expressions from a file for analysis.  Analysis consists of<br>  applying a set of rules to the semi-expression, and for each rule<br>  that matches, invokes a set of one or more actions.<br><br>  Public Interface:<br>  =================<br>  Toker t(someFile);              // create tokenizer instance<br>  SemiExp se(&t);                 // create a SemiExp attached to tokenizer<br>  Parser parser(se);              // now we have a parser<br>  Rule1 r1;                       // create instance of a derived Rule class<br>  Action1 a1;                     // create a derived action<br>  r1.addAction(&a1);              // register action with the rule<br>  parser.addRule(&r1);            // register rule with parser<br>  while(se.getSemiExp())          // get semi-expression<br>    parser.parse();               //   and parse it<br><br>  Build Process:<br>  ==============<br>  Required files<br>    - Parser.h, Parser.cpp, SemiExpression.h, SemiExpression.cpp,<br>      tokenizer.h, tokenizer.cpp,<br>      ActionsAndRules.h, ActionsAndRules.cpp,<br>      ConfigureParser.h, ConfigureParser.cpp<br>  Build commands (either one)<br>    - devenv Parser.sln<br>    - cl /EHsc /DTEST_PARSER parser.cpp semiexpression.cpp tokenizer.cpp \<br>         ActionsAndRules.cpp ConfigureParser.cpp /link setargv.obj<br><br>  Maintenance History:<br>  ====================<br>  ver 1.5 : 19 Aug 16<br>  - added trimming of semis in Parser::next()<br>  - changed IRule interface to accept const pointer<br>  - Now stops processing rules for a SemiExp if a rule returns IRule::Stop.<br>    It continues by collecting another SemiExp for testing.<br>  ver 1.4 : 15 Feb 16<br>  - removed all folding rules code<br>  - changed solution folder layout which caused changes in many of the<br>    include paths<br>  - small modifications to one of the derived actions<br>  - now preface (new) Toker and SemiExp with Scanner namespace<br>  ver 1.3 : 02 Jun 11<br>  - added use of folding rules in get();<br>  ver 1.2 : 17 Jan 09<br>  - modified to accept pointer to interface ITokCollection instead of<br>    SemiExpression<br>  ver 1.1 : 17 Sep 07<br>  - cosmetic modifications to comments on this page<br>  ver 1.0 : 12 Jan 06<br>  - first release<br><br>*/<br><br>#include &lt;string&gt;<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include "../SemiExp/itokcollection.h"<br><br>namespace CodeAnalysis<br>{ <button onclick = "myFunction1()">-</button><div id = "myDIV1"><br>  ///////////////////////////////////////////////////////////////<br>  // abstract base class for parsing actions<br>  //   - when a rule succeeds, it invokes any registered action<br><br>  class Parser;<br><br>  class IBuilder<br>  { <button onclick = "myFunction1()">-</button><div id = "myDIV1"><br>  public:<br>    virtual ~IBuilder() { <button onclick = "myFunction1()">-</button><div id = "myDIV1">}</div><script>function myFunction1() {var x = document.getElementById('myDIV1');if (x.style.display == 'none') {x.style.display = 'block';this.value = "+";}else {x.style.display = 'none';this.value = "-";}}</script><br>    virtual Parser* Build() = 0;<br>  }</div><script>function myFunction2() {var x = document.getElementById('myDIV2');if (x.style.display == 'none') {x.style.display = 'block';this.value = "+";}else {x.style.display = 'none';this.value = "-";}}</script>;<br><br>  ///////////////////////////////////////////////////////////////<br>  // abstract base class for parsing actions<br>  //   - when a rule succeeds, it invokes any registered action<br><br>  class IAction<br>  { <button onclick = "myFunction3()">-</button><div id = "myDIV3"><br>  public:<br>    virtual ~IAction() { <button onclick = "myFunction3()">-</button><div id = "myDIV3">}</div><script>function myFunction3() {var x = document.getElementById('myDIV3');if (x.style.display == 'none') {x.style.display = 'block';this.value = "+";}else {x.style.display = 'none';this.value = "-";}}</script><br>    virtual void doAction(const Scanner::ITokCollection* pTc) = 0;<br>  }</div><script>function myFunction4() {var x = document.getElementById('myDIV4');if (x.style.display == 'none') {x.style.display = 'block';this.value = "+";}else {x.style.display = 'none';this.value = "-";}}</script>;<br><br>  ///////////////////////////////////////////////////////////////<br>  // abstract base class for parser language construct detections<br>  //   - rules are registered with the parser for use<br><br>  class IRule<br>  { <button onclick = "myFunction5()">-</button><div id = "myDIV5"><br>  public:<br>    static const bool Continue = true;<br>    static const bool Stop = false;<br>    virtual ~IRule() { <button onclick = "myFunction5()">-</button><div id = "myDIV5">}</div><script>function myFunction5() {var x = document.getElementById('myDIV5');if (x.style.display == 'none') {x.style.display = 'block';this.value = "+";}else {x.style.display = 'none';this.value = "-";}}</script><br>    void addAction(IAction* pAction);<br>    void doActions(const Scanner::ITokCollection* pTc);<br>    virtual bool doTest(const Scanner::ITokCollection* pTc) = 0;<br>  protected:<br>    std::vector&lt;IAction*&gt; actions;<br>  }</div><script>function myFunction6() {var x = document.getElementById('myDIV6');if (x.style.display == 'none') {x.style.display = 'block';this.value = "+";}else {x.style.display = 'none';this.value = "-";}}</script>;<br><br>  class Parser<br>  { <button onclick = "myFunction7()">-</button><div id = "myDIV7"><br>  public:<br>    Parser(Scanner::ITokCollection* pTokCollection);<br>    ~Parser();<br>    void addRule(IRule* pRule);<br>    bool parse();<br>    bool next();<br>  private:<br>    Scanner::ITokCollection* pTokColl;<br>    std::vector&lt;IRule*&gt; rules;<br>  }</div><script>function myFunction7() {var x = document.getElementById('myDIV7');if (x.style.display == 'none') {x.style.display = 'block';this.value = "+";}else {x.style.display = 'none';this.value = "-";}}</script>;<br><br>  inline Parser::Parser(Scanner::ITokCollection* pTokCollection) : pTokColl(pTokCollection) { <button onclick = "myFunction8()">-</button><div id = "myDIV8">}</div><script>function myFunction8() {var x = document.getElementById('myDIV8');if (x.style.display == 'none') {x.style.display = 'block';this.value = "+";}else {x.style.display = 'none';this.value = "-";}}</script><br><br>  inline Parser::~Parser() { <button onclick = "myFunction9()">-</button><div id = "myDIV9">}</div><script>function myFunction9() {var x = document.getElementById('myDIV9');if (x.style.display == 'none') {x.style.display = 'block';this.value = "+";}else {x.style.display = 'none';this.value = "-";}}</script><br>}</div><script>function myFunction10() {var x = document.getElementById('myDIV10');if (x.style.display == 'none') {x.style.display = 'block';this.value = "+";}else {x.style.display = 'none';this.value = "-";}}</script><br>#endif<br></pre</body></html>